{"ast":null,"code":"import _regeneratorRuntime from \"C:\\\\Users\\\\PIONEER\\\\Documents\\\\projects\\\\endurance-sample\\\\srabonti-sample-ui\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/regenerator\";\nimport _asyncToGenerator from \"C:\\\\Users\\\\PIONEER\\\\Documents\\\\projects\\\\endurance-sample\\\\srabonti-sample-ui\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/asyncToGenerator\";\nimport { isNullOrUndefined } from \"util\";\nimport { replaceNull, deleteKeysFromObject } from '../utility/generalFunctions';\n\nrequire('isomorphic-fetch');\n\nexport function getDataApiOptions(requestOptions, requestBody) {\n  var options = {\n    method: requestOptions.method,\n    headers: {\n      'Accept': 'application/json',\n      'Content-Type': 'application/json',\n      'Authorization': 'Bearer ' + requestOptions.authToken\n    }\n  };\n\n  if (!isNullOrUndefined(requestBody)) {\n    options.body = JSON.stringify(requestBody);\n  }\n\n  return options;\n}\nexport var fetchData = function fetchData(url, options) {\n  var fetchRequest = new Request(url, options);\n  return fetch(fetchRequest).then(function (response) {\n    return response.json().then(function (result) {\n      return {\n        result: result\n      };\n    });\n  }).catch(function (error) {\n    return {\n      error: error\n    };\n  });\n};\nexport function fetchDataAndDispatch(url, options, dispatch, type, typeError) {\n  var fetchRequest = new Request(url, options);\n  return fetch(fetchRequest).then(function (response) {\n    return response.json().then(function (result) {\n      result.responseStatus.statusDescription === \"Success\" ? dispatch({\n        type: type,\n        payload: {\n          data: result.responseData[0],\n          error: null,\n          loaded: true\n        }\n      }) : dispatch({\n        type: type,\n        payload: {\n          data: null,\n          error: result.responseStatus,\n          loaded: true\n        }\n      });\n    });\n  }).catch(function (error) {\n    console.log(error);\n    dispatch({\n      type: type,\n      payload: {\n        data: null,\n        error: error.responseStatus ? error.responseStatus : {\n          errorMessage: [{\n            key: \"generic.error\",\n            message: \"Server is down\"\n          }],\n          \"httpStatusCode\": 500,\n          \"httpSubStatusCode\": 500,\n          \"statusDesc\": \"ServerFailure\"\n        },\n        loaded: true\n      }\n    });\n  });\n} // //TODO: account for multiple types in array\n// export function fetchDataAndDispatchWithPromise(url, options, dispatch, type, typeError) {\n//  try {\n//     const responseData = await this.fetchDataAndDispatch(url, options, dispatch, type);  \n//   }\n//   catch (err) { \n//   }\n//   return Promise.resolve();\n// };\n\n/**\n * returns object from clientconfig based on the key specified.\n * @param {object} configObject \n * @param {string} key \n */\n\nexport var getObjectFromClientConfig = function getObjectFromClientConfig(configObject, key, keyType, searchText) {\n  var searchValue = null;\n\n  if (configObject && key && configObject[key]) {\n    searchValue = configObject[key].find(function (configItem) {\n      var type = \"\".concat(keyType, \"Type\");\n\n      if (configItem[type] === searchText) {\n        return configItem;\n      }\n\n      return null;\n    });\n  }\n\n  return searchValue;\n};\n/**\n * returns a value from clientconfig based on the key specified.\n * @param {object} configObject \n * @param {string} key \n */\n\nexport var getValueFromClientConfig = function getValueFromClientConfig(configObject, key, keyType, searchText) {\n  var configValue = null;\n  var clientData = getObjectFromClientConfig(configObject, key, keyType, searchText);\n\n  if (clientData) {\n    var value = \"\".concat(keyType, \"Value\");\n    configValue = clientData[value];\n  }\n\n  return configValue;\n};\nexport function searchAndDispatch(url, options, dispatch, type, searchFilters) {\n  var fetchRequest = new Request(url, options);\n  return fetch(fetchRequest).then(function (response) {\n    return response.json().then(function (result) {\n      result.responseStatus.statusDescription === \"Success\" ? dispatch({\n        type: type,\n        payload: {\n          data: result.pageSize ? replaceNull(deleteKeysFromObject(result, [\"responseStatus\"])) : replaceNull(result.responseData[0]),\n          error: null,\n          loaded: true\n        },\n        searchFilters: searchFilters\n      }) : dispatch({\n        type: type,\n        payload: {\n          data: null,\n          error: result.responseStatus,\n          loaded: true\n        },\n        searchFilters: searchFilters\n      });\n    });\n  }).catch(function (error) {\n    console.log(error);\n    dispatch({\n      type: type,\n      payload: {\n        data: null,\n        error: error.responseStatus ? error.responseStatus : {\n          errorMessage: [{\n            key: \"generic.error\",\n            message: \"Server is down\"\n          }],\n          \"httpStatusCode\": 500,\n          \"httpSubStatusCode\": 500,\n          \"statusDesc\": \"ServerFailure\"\n        },\n        loaded: true\n      },\n      searchFilters: searchFilters\n    });\n  });\n}\nexport function getDataApiOptionsNotAuthenticated(requestOptions, requestBody) {\n  var options = {\n    method: requestOptions.method,\n    headers: {\n      'Accept': 'application/json',\n      'Content-Type': 'application/json',\n      'Client-Name': requestOptions.clientName\n    },\n    body: JSON.stringify(requestBody)\n  };\n  return options;\n}\nexport function fetchWithoutDispatch(url, options) {\n  return /*#__PURE__*/function () {\n    var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(dispatch) {\n      var response, payload, result;\n      return _regeneratorRuntime.wrap(function _callee$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              response = undefined;\n              payload = undefined;\n              _context.prev = 2;\n              _context.next = 5;\n              return fetchData(url, options);\n\n            case 5:\n              response = _context.sent;\n              result = response.result;\n              result.responseStatus.statusDescription === \"Success\" ? payload = {\n                data: result.pageSize ? replaceNull(deleteKeysFromObject(result, [\"responseStatus\"])) : replaceNull(result.responseData[0]),\n                status: result.responseStatus,\n                loaded: true\n              } : payload = {\n                data: null,\n                status: result.responseStatus,\n                loaded: true\n              };\n              _context.next = 14;\n              break;\n\n            case 10:\n              _context.prev = 10;\n              _context.t0 = _context[\"catch\"](2);\n              console.error('error while fetchWithoutDispatch', _context.t0);\n              payload = {\n                data: null,\n                status: _context.t0.responseStatus ? _context.t0.responseStatus : {\n                  errorMessage: [{\n                    key: \"generic.error\",\n                    message: \"Server is down\"\n                  }],\n                  \"httpStatusCode\": 500,\n                  \"httpSubStatusCode\": 500,\n                  \"statusDesc\": \"ServerFailure\"\n                },\n                loaded: true\n              };\n\n            case 14:\n              return _context.abrupt(\"return\", Promise.resolve(payload));\n\n            case 15:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      }, _callee, null, [[2, 10]]);\n    }));\n\n    return function (_x) {\n      return _ref.apply(this, arguments);\n    };\n  }();\n}","map":{"version":3,"sources":["C:/Users/PIONEER/Documents/projects/endurance-sample/srabonti-sample-ui/src/utility/actionHelper.js"],"names":["isNullOrUndefined","replaceNull","deleteKeysFromObject","require","getDataApiOptions","requestOptions","requestBody","options","method","headers","authToken","body","JSON","stringify","fetchData","url","fetchRequest","Request","fetch","then","response","json","result","catch","error","fetchDataAndDispatch","dispatch","type","typeError","responseStatus","statusDescription","payload","data","responseData","loaded","console","log","errorMessage","key","message","getObjectFromClientConfig","configObject","keyType","searchText","searchValue","find","configItem","getValueFromClientConfig","configValue","clientData","value","searchAndDispatch","searchFilters","pageSize","getDataApiOptionsNotAuthenticated","clientName","fetchWithoutDispatch","undefined","status","Promise","resolve"],"mappings":";;AAAA,SAASA,iBAAT,QAAkC,MAAlC;AACA,SAASC,WAAT,EAAsBC,oBAAtB,QAAkD,6BAAlD;;AACAC,OAAO,CAAC,kBAAD,CAAP;;AAGA,OAAO,SAASC,iBAAT,CAA2BC,cAA3B,EAA2CC,WAA3C,EAAwD;AAC7D,MAAIC,OAAO,GAAG;AACZC,IAAAA,MAAM,EAAEH,cAAc,CAACG,MADX;AAEZC,IAAAA,OAAO,EAAE;AACP,gBAAU,kBADH;AAEP,sBAAgB,kBAFT;AAGP,uBAAiB,YAAYJ,cAAc,CAACK;AAHrC;AAFG,GAAd;;AAQA,MAAI,CAACV,iBAAiB,CAACM,WAAD,CAAtB,EAAqC;AACnCC,IAAAA,OAAO,CAACI,IAAR,GAAeC,IAAI,CAACC,SAAL,CAAeP,WAAf,CAAf;AACD;;AACD,SAAOC,OAAP;AACD;AAID,OAAO,IAAMO,SAAS,GAAG,SAAZA,SAAY,CAACC,GAAD,EAAMR,OAAN,EAAkB;AACzC,MAAMS,YAAY,GAAG,IAAIC,OAAJ,CAAYF,GAAZ,EAAiBR,OAAjB,CAArB;AACA,SAAOW,KAAK,CAACF,YAAD,CAAL,CACJG,IADI,CACC,UAAAC,QAAQ;AAAA,WAAIA,QAAQ,CAACC,IAAT,GAAgBF,IAAhB,CAAqB,UAAAG,MAAM;AAAA,aAAK;AAAEA,QAAAA,MAAM,EAANA;AAAF,OAAL;AAAA,KAA3B,CAAJ;AAAA,GADT,EAEJC,KAFI,CAEE,UAAAC,KAAK;AAAA,WAAK;AAAEA,MAAAA,KAAK,EAALA;AAAF,KAAL;AAAA,GAFP,CAAP;AAGD,CALM;AAQP,OAAO,SAASC,oBAAT,CAA8BV,GAA9B,EAAmCR,OAAnC,EAA4CmB,QAA5C,EAAsDC,IAAtD,EAA4DC,SAA5D,EAAuE;AAC5E,MAAMZ,YAAY,GAAG,IAAIC,OAAJ,CAAYF,GAAZ,EAAiBR,OAAjB,CAArB;AACA,SAAOW,KAAK,CAACF,YAAD,CAAL,CACJG,IADI,CACC,UAAAC,QAAQ;AAAA,WAAIA,QAAQ,CAACC,IAAT,GAAgBF,IAAhB,CAAqB,UAAAG,MAAM,EAAI;AAC/CA,MAAAA,MAAM,CAACO,cAAP,CAAsBC,iBAAtB,KAA4C,SAA5C,GAAwDJ,QAAQ,CAC9D;AACEC,QAAAA,IAAI,EAAJA,IADF;AAEEI,QAAAA,OAAO,EAAE;AACPC,UAAAA,IAAI,EAAGV,MAAM,CAACW,YAAP,CAAoB,CAApB,CADA;AAEPT,UAAAA,KAAK,EAAE,IAFA;AAGPU,UAAAA,MAAM,EAAE;AAHD;AAFX,OAD8D,CAAhE,GASIR,QAAQ,CAAC;AACTC,QAAAA,IAAI,EAAEA,IADG;AAETI,QAAAA,OAAO,EAAE;AACPC,UAAAA,IAAI,EAAE,IADC;AAEPR,UAAAA,KAAK,EAAEF,MAAM,CAACO,cAFP;AAGPK,UAAAA,MAAM,EAAE;AAHD;AAFA,OAAD,CATZ;AAiBD,KAlBiB,CAAJ;AAAA,GADT,EAoBJX,KApBI,CAoBE,UAAAC,KAAK,EAAI;AACdW,IAAAA,OAAO,CAACC,GAAR,CAAYZ,KAAZ;AACAE,IAAAA,QAAQ,CAAC;AACPC,MAAAA,IAAI,EAAEA,IADC;AAEPI,MAAAA,OAAO,EAAE;AACPC,QAAAA,IAAI,EAAE,IADC;AAEPR,QAAAA,KAAK,EAAEA,KAAK,CAACK,cAAN,GAAuBL,KAAK,CAACK,cAA7B,GAA8C;AACnDQ,UAAAA,YAAY,EAAE,CAAC;AACbC,YAAAA,GAAG,EAAE,eADQ;AAEbC,YAAAA,OAAO,EAAE;AAFI,WAAD,CADqC;AAKnD,4BAAkB,GALiC;AAMnD,+BAAqB,GAN8B;AAOnD,wBAAc;AAPqC,SAF9C;AAWPL,QAAAA,MAAM,EAAE;AAXD;AAFF,KAAD,CAAR;AAgBD,GAtCI,CAAP;AAuCD,C,CAGD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAGA;;;;;;AAKA,OAAO,IAAMM,yBAAyB,GAAG,SAA5BA,yBAA4B,CAACC,YAAD,EAAeH,GAAf,EAAoBI,OAApB,EAA6BC,UAA7B,EAA4C;AACnF,MAAIC,WAAW,GAAG,IAAlB;;AACA,MAAIH,YAAY,IAAIH,GAAhB,IAAuBG,YAAY,CAACH,GAAD,CAAvC,EAA8C;AAC5CM,IAAAA,WAAW,GAAGH,YAAY,CAACH,GAAD,CAAZ,CAAkBO,IAAlB,CAAuB,UAAUC,UAAV,EAAsB;AACzD,UAAMnB,IAAI,aAAMe,OAAN,SAAV;;AACA,UAAII,UAAU,CAACnB,IAAD,CAAV,KAAqBgB,UAAzB,EAAqC;AACnC,eAAOG,UAAP;AACD;;AACD,aAAO,IAAP;AACD,KANa,CAAd;AAOD;;AACD,SAAOF,WAAP;AACD,CAZM;AAcP;;;;;;AAKA,OAAO,IAAMG,wBAAwB,GAAG,SAA3BA,wBAA2B,CAACN,YAAD,EAAeH,GAAf,EAAoBI,OAApB,EAA6BC,UAA7B,EAA4C;AAClF,MAAIK,WAAW,GAAG,IAAlB;AACA,MAAIC,UAAU,GAAGT,yBAAyB,CAACC,YAAD,EAAeH,GAAf,EAAoBI,OAApB,EAA6BC,UAA7B,CAA1C;;AACA,MAAIM,UAAJ,EAAgB;AACd,QAAMC,KAAK,aAAMR,OAAN,UAAX;AACAM,IAAAA,WAAW,GAAGC,UAAU,CAACC,KAAD,CAAxB;AACD;;AACD,SAAOF,WAAP;AACD,CARM;AAUP,OAAO,SAASG,iBAAT,CAA2BpC,GAA3B,EAAgCR,OAAhC,EAAyCmB,QAAzC,EAAmDC,IAAnD,EAAyDyB,aAAzD,EAAwE;AAC7E,MAAMpC,YAAY,GAAG,IAAIC,OAAJ,CAAYF,GAAZ,EAAiBR,OAAjB,CAArB;AACA,SAAOW,KAAK,CAACF,YAAD,CAAL,CACJG,IADI,CACC,UAAAC,QAAQ;AAAA,WAAIA,QAAQ,CAACC,IAAT,GAAgBF,IAAhB,CAAqB,UAAAG,MAAM,EAAI;AAC/CA,MAAAA,MAAM,CAACO,cAAP,CAAsBC,iBAAtB,KAA4C,SAA5C,GAAwDJ,QAAQ,CAC9D;AACEC,QAAAA,IAAI,EAAJA,IADF;AAEEI,QAAAA,OAAO,EAAE;AACPC,UAAAA,IAAI,EAAEV,MAAM,CAAC+B,QAAP,GAAkBpD,WAAW,CAACC,oBAAoB,CAACoB,MAAD,EAAS,CAAC,gBAAD,CAAT,CAArB,CAA7B,GAAkFrB,WAAW,CAACqB,MAAM,CAACW,YAAP,CAAoB,CAApB,CAAD,CAD5F;AAEPT,UAAAA,KAAK,EAAE,IAFA;AAGPU,UAAAA,MAAM,EAAE;AAHD,SAFX;AAOEkB,QAAAA,aAAa,EAAEA;AAPjB,OAD8D,CAAhE,GAUI1B,QAAQ,CAAC;AACTC,QAAAA,IAAI,EAAEA,IADG;AAETI,QAAAA,OAAO,EAAE;AACPC,UAAAA,IAAI,EAAE,IADC;AAEPR,UAAAA,KAAK,EAAEF,MAAM,CAACO,cAFP;AAGPK,UAAAA,MAAM,EAAE;AAHD,SAFA;AAOTkB,QAAAA,aAAa,EAAEA;AAPN,OAAD,CAVZ;AAmBD,KApBiB,CAAJ;AAAA,GADT,EAsBJ7B,KAtBI,CAsBE,UAAAC,KAAK,EAAI;AACdW,IAAAA,OAAO,CAACC,GAAR,CAAYZ,KAAZ;AACAE,IAAAA,QAAQ,CAAC;AACPC,MAAAA,IAAI,EAAEA,IADC;AAEPI,MAAAA,OAAO,EAAE;AACPC,QAAAA,IAAI,EAAE,IADC;AAEPR,QAAAA,KAAK,EAAEA,KAAK,CAACK,cAAN,GAAuBL,KAAK,CAACK,cAA7B,GAA8C;AACnDQ,UAAAA,YAAY,EAAE,CAAC;AACbC,YAAAA,GAAG,EAAE,eADQ;AAEbC,YAAAA,OAAO,EAAE;AAFI,WAAD,CADqC;AAKnD,4BAAkB,GALiC;AAMnD,+BAAqB,GAN8B;AAOnD,wBAAc;AAPqC,SAF9C;AAWPL,QAAAA,MAAM,EAAE;AAXD,OAFF;AAePkB,MAAAA,aAAa,EAAEA;AAfR,KAAD,CAAR;AAiBD,GAzCI,CAAP;AA0CD;AAED,OAAO,SAASE,iCAAT,CAA2CjD,cAA3C,EAA2DC,WAA3D,EAAwE;AAC7E,MAAMC,OAAO,GAAG;AACdC,IAAAA,MAAM,EAAEH,cAAc,CAACG,MADT;AAEdC,IAAAA,OAAO,EAAE;AACP,gBAAU,kBADH;AAEP,sBAAgB,kBAFT;AAGP,qBAAeJ,cAAc,CAACkD;AAHvB,KAFK;AAOd5C,IAAAA,IAAI,EAAEC,IAAI,CAACC,SAAL,CAAeP,WAAf;AAPQ,GAAhB;AASA,SAAOC,OAAP;AACD;AAED,OAAO,SAASiD,oBAAT,CAA8BzC,GAA9B,EAAmCR,OAAnC,EAA4C;AACjD;AAAA,wEAAO,iBAAOmB,QAAP;AAAA;AAAA;AAAA;AAAA;AAAA;AACDN,cAAAA,QADC,GACUqC,SADV;AAED1B,cAAAA,OAFC,GAES0B,SAFT;AAAA;AAAA;AAAA,qBAIc3C,SAAS,CAACC,GAAD,EAAMR,OAAN,CAJvB;;AAAA;AAIHa,cAAAA,QAJG;AAKCE,cAAAA,MALD,GAKUF,QAAQ,CAACE,MALnB;AAMHA,cAAAA,MAAM,CAACO,cAAP,CAAsBC,iBAAtB,KAA4C,SAA5C,GACEC,OAAO,GAAG;AACRC,gBAAAA,IAAI,EAAEV,MAAM,CAAC+B,QAAP,GAAkBpD,WAAW,CAACC,oBAAoB,CAACoB,MAAD,EAAS,CAAC,gBAAD,CAAT,CAArB,CAA7B,GAAkFrB,WAAW,CAACqB,MAAM,CAACW,YAAP,CAAoB,CAApB,CAAD,CAD3F;AAERyB,gBAAAA,MAAM,EAAEpC,MAAM,CAACO,cAFP;AAGRK,gBAAAA,MAAM,EAAE;AAHA,eADZ,GAMEH,OAAO,GAAG;AACRC,gBAAAA,IAAI,EAAE,IADE;AAER0B,gBAAAA,MAAM,EAAEpC,MAAM,CAACO,cAFP;AAGRK,gBAAAA,MAAM,EAAE;AAHA,eANZ;AANG;AAAA;;AAAA;AAAA;AAAA;AAmBHC,cAAAA,OAAO,CAACX,KAAR,CAAc,kCAAd;AACAO,cAAAA,OAAO,GAAG;AACRC,gBAAAA,IAAI,EAAE,IADE;AAER0B,gBAAAA,MAAM,EAAE,YAAI7B,cAAJ,GAAqB,YAAIA,cAAzB,GAA0C;AAChDQ,kBAAAA,YAAY,EAAE,CAAC;AACbC,oBAAAA,GAAG,EAAE,eADQ;AAEbC,oBAAAA,OAAO,EAAE;AAFI,mBAAD,CADkC;AAKhD,oCAAkB,GAL8B;AAMhD,uCAAqB,GAN2B;AAOhD,gCAAc;AAPkC,iBAF1C;AAWRL,gBAAAA,MAAM,EAAE;AAXA,eAAV;;AApBG;AAAA,+CAkCEyB,OAAO,CAACC,OAAR,CAAgB7B,OAAhB,CAlCF;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,KAAP;;AAAA;AAAA;AAAA;AAAA;AAoCD","sourcesContent":["import { isNullOrUndefined } from \"util\";\nimport { replaceNull, deleteKeysFromObject } from '../utility/generalFunctions';\nrequire('isomorphic-fetch');\n\n\nexport function getDataApiOptions(requestOptions, requestBody) {\n  let options = {\n    method: requestOptions.method,\n    headers: {\n      'Accept': 'application/json',\n      'Content-Type': 'application/json',\n      'Authorization': 'Bearer ' + requestOptions.authToken\n    }\n  }\n  if (!isNullOrUndefined(requestBody)) {\n    options.body = JSON.stringify(requestBody);\n  }\n  return options;\n}\n\n \n\nexport const fetchData = (url, options) => {\n  const fetchRequest = new Request(url, options);\n  return fetch(fetchRequest)\n    .then(response => response.json().then(result => ({ result })))\n    .catch(error => ({ error }));\n};\n\n\nexport function fetchDataAndDispatch(url, options, dispatch, type, typeError) {\n  const fetchRequest = new Request(url, options);\n  return fetch(fetchRequest)\n    .then(response => response.json().then(result => {\n      result.responseStatus.statusDescription === \"Success\" ? dispatch(\n        {\n          type,\n          payload: {\n            data: (result.responseData[0]),\n            error: null,\n            loaded: true\n          }\n        })\n        : dispatch({\n          type: type,\n          payload: {\n            data: null,\n            error: result.responseStatus,\n            loaded: true\n          }\n        });\n    }))\n    .catch(error => {\n      console.log(error)\n      dispatch({\n        type: type,\n        payload: {\n          data: null,\n          error: error.responseStatus ? error.responseStatus : {\n            errorMessage: [{\n              key: \"generic.error\",\n              message: \"Server is down\"\n            }],\n            \"httpStatusCode\": 500,\n            \"httpSubStatusCode\": 500,\n            \"statusDesc\": \"ServerFailure\"\n          },\n          loaded: true\n        }\n      })\n    });\n}\n\n\n// //TODO: account for multiple types in array\n// export function fetchDataAndDispatchWithPromise(url, options, dispatch, type, typeError) {\n//  try {\n//     const responseData = await this.fetchDataAndDispatch(url, options, dispatch, type);  \n//   }\n//   catch (err) { \n//   }\n//   return Promise.resolve();\n// };\n\n\n/**\n * returns object from clientconfig based on the key specified.\n * @param {object} configObject \n * @param {string} key \n */\nexport const getObjectFromClientConfig = (configObject, key, keyType, searchText) => {\n  let searchValue = null;\n  if (configObject && key && configObject[key]) {\n    searchValue = configObject[key].find(function (configItem) {\n      const type = `${keyType}Type`;\n      if (configItem[type] === searchText) {\n        return configItem;\n      }\n      return null;\n    });\n  }\n  return searchValue;\n}\n\n/**\n * returns a value from clientconfig based on the key specified.\n * @param {object} configObject \n * @param {string} key \n */\nexport const getValueFromClientConfig = (configObject, key, keyType, searchText) => {\n  let configValue = null;\n  let clientData = getObjectFromClientConfig(configObject, key, keyType, searchText);\n  if (clientData) {\n    const value = `${keyType}Value`;\n    configValue = clientData[value];\n  }\n  return configValue;\n}\n\nexport function searchAndDispatch(url, options, dispatch, type, searchFilters) {\n  const fetchRequest = new Request(url, options);\n  return fetch(fetchRequest)\n    .then(response => response.json().then(result => {\n      result.responseStatus.statusDescription === \"Success\" ? dispatch(\n        {\n          type,\n          payload: {\n            data: result.pageSize ? replaceNull(deleteKeysFromObject(result, [\"responseStatus\"])) : replaceNull(result.responseData[0]),\n            error: null,\n            loaded: true\n          },\n          searchFilters: searchFilters\n        })\n        : dispatch({\n          type: type,\n          payload: {\n            data: null,\n            error: result.responseStatus,\n            loaded: true\n          },\n          searchFilters: searchFilters\n        });\n    }))\n    .catch(error => {\n      console.log(error)\n      dispatch({\n        type: type,\n        payload: {\n          data: null,\n          error: error.responseStatus ? error.responseStatus : {\n            errorMessage: [{\n              key: \"generic.error\",\n              message: \"Server is down\"\n            }],\n            \"httpStatusCode\": 500,\n            \"httpSubStatusCode\": 500,\n            \"statusDesc\": \"ServerFailure\"\n          },\n          loaded: true\n        },\n        searchFilters: searchFilters\n      })\n    });\n}\n\nexport function getDataApiOptionsNotAuthenticated(requestOptions, requestBody) {\n  const options = {\n    method: requestOptions.method,\n    headers: {\n      'Accept': 'application/json',\n      'Content-Type': 'application/json',\n      'Client-Name': requestOptions.clientName\n    },\n    body: JSON.stringify(requestBody)\n  }\n  return options;\n}\n\nexport function fetchWithoutDispatch(url, options) {\n  return async (dispatch) => {\n    let response = undefined;\n    let payload = undefined;\n    try {\n      response = await fetchData(url, options);\n      let result = response.result;\n      result.responseStatus.statusDescription === \"Success\" ?\n        payload = {\n          data: result.pageSize ? replaceNull(deleteKeysFromObject(result, [\"responseStatus\"])) : replaceNull(result.responseData[0]),\n          status: result.responseStatus,\n          loaded: true\n        } :\n        payload = {\n          data: null,\n          status: result.responseStatus,\n          loaded: true\n        }\n    }\n    catch (err) {\n      console.error('error while fetchWithoutDispatch', err);\n      payload = {\n        data: null,\n        status: err.responseStatus ? err.responseStatus : {\n          errorMessage: [{\n            key: \"generic.error\",\n            message: \"Server is down\"\n          }],\n          \"httpStatusCode\": 500,\n          \"httpSubStatusCode\": 500,\n          \"statusDesc\": \"ServerFailure\"\n        },\n        loaded: true\n      }\n    }\n    return Promise.resolve(payload);\n  };\n}"]},"metadata":{},"sourceType":"module"}