{"ast":null,"code":"import _regeneratorRuntime from \"C:\\\\Users\\\\PIONEER\\\\Documents\\\\projects\\\\endurance-sample\\\\srabonti-sample-ui\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/regenerator\";\nimport _asyncToGenerator from \"C:\\\\Users\\\\PIONEER\\\\Documents\\\\projects\\\\endurance-sample\\\\srabonti-sample-ui\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/asyncToGenerator\";\nimport { isNullOrUndefined } from \"util\";\nimport { replaceNull, deleteKeysFromObject } from '../utility/generalFunctions';\n\nrequire('isomorphic-fetch');\n\nexport function getDataApiOptions(requestOptions, requestBody) {\n  var options = {\n    method: requestOptions.method,\n    headers: {\n      'Accept': 'application/json',\n      'Content-Type': 'application/json',\n      'Authorization': 'Bearer ' + requestOptions.authToken\n    }\n  };\n\n  if (!isNullOrUndefined(requestBody)) {\n    options.body = JSON.stringify(requestBody);\n  }\n\n  return options;\n}\nexport var fetchData = function fetchData(url, options) {\n  var fetchRequest = new Request(url, options);\n  return fetch(fetchRequest).then(function (response) {\n    return response.json().then(function (result) {\n      return {\n        result: result\n      };\n    });\n  }).catch(function (error) {\n    return {\n      error: error\n    };\n  });\n};\nexport function fetchDataAndDispatch(url, options, dispatch, type, typeError) {\n  var fetchRequest = new Request(url, options);\n  return fetch(fetchRequest).then(function (response) {\n    return response.json().then(function (result) {\n      result.responseStatus.statusDescription === \"Success\" ? dispatch({\n        type: type,\n        payload: {\n          data: result.responseData[0],\n          error: null,\n          loaded: true\n        }\n      }) : dispatch({\n        type: type,\n        payload: {\n          data: null,\n          error: result.responseStatus,\n          loaded: true\n        }\n      });\n    });\n  }).catch(function (error) {\n    console.log(error);\n    dispatch({\n      type: type,\n      payload: {\n        data: null,\n        error: error.responseStatus ? error.responseStatus : {\n          errorMessage: [{\n            key: \"generic.error\",\n            message: \"Server is down\"\n          }],\n          \"httpStatusCode\": 500,\n          \"httpSubStatusCode\": 500,\n          \"statusDesc\": \"ServerFailure\"\n        },\n        loaded: true\n      }\n    });\n  });\n} // //TODO: account for multiple types in array\n// export function fetchDataAndDispatchWithPromise(url, options, dispatch, type, typeError) {\n//  try {\n//     const responseData = await this.fetchDataAndDispatch(url, options, dispatch, type);  \n//   }\n//   catch (err) { \n//   }\n//   return Promise.resolve();\n// };\n\n/**\n * returns object from clientconfig based on the key specified.\n * @param {object} configObject \n * @param {string} key \n */\n\n/**\n * returns a value from clientconfig based on the key specified.\n * @param {object} configObject \n * @param {string} key \n */\n\nexport var getValueFromClientConfig = function getValueFromClientConfig(configObject, key, keyType, searchText) {\n  var configValue = null;\n  var clientData = getObjectFromClientConfig(configObject, key, keyType, searchText);\n\n  if (clientData) {\n    var value = \"\".concat(keyType, \"Value\");\n    configValue = clientData[value];\n  }\n\n  return configValue;\n};\nexport function searchAndDispatch(url, options, dispatch, type, searchFilters) {\n  var fetchRequest = new Request(url, options);\n  return fetch(fetchRequest).then(function (response) {\n    return response.json().then(function (result) {\n      result.responseStatus.statusDescription === \"Success\" ? dispatch({\n        type: type,\n        payload: {\n          data: result.pageSize ? replaceNull(deleteKeysFromObject(result, [\"responseStatus\"])) : replaceNull(result.responseData[0]),\n          error: null,\n          loaded: true\n        },\n        searchFilters: searchFilters\n      }) : dispatch({\n        type: type,\n        payload: {\n          data: null,\n          error: result.responseStatus,\n          loaded: true\n        },\n        searchFilters: searchFilters\n      });\n    });\n  }).catch(function (error) {\n    console.log(error);\n    dispatch({\n      type: type,\n      payload: {\n        data: null,\n        error: error.responseStatus ? error.responseStatus : {\n          errorMessage: [{\n            key: \"generic.error\",\n            message: \"Server is down\"\n          }],\n          \"httpStatusCode\": 500,\n          \"httpSubStatusCode\": 500,\n          \"statusDesc\": \"ServerFailure\"\n        },\n        loaded: true\n      },\n      searchFilters: searchFilters\n    });\n  });\n}\nexport function getDataApiOptionsNotAuthenticated(requestOptions, requestBody) {\n  var options = {\n    method: requestOptions.method,\n    headers: {\n      'Accept': 'application/json',\n      'Content-Type': 'application/json',\n      'Client-Name': requestOptions.clientName\n    },\n    body: JSON.stringify(requestBody)\n  };\n  return options;\n}\nexport function fetchWithoutDispatch(url, options) {\n  return /*#__PURE__*/function () {\n    var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(dispatch) {\n      var response, payload, result;\n      return _regeneratorRuntime.wrap(function _callee$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              response = undefined;\n              payload = undefined;\n              _context.prev = 2;\n              _context.next = 5;\n              return fetchData(url, options);\n\n            case 5:\n              response = _context.sent;\n              result = response.result;\n              result.responseStatus.statusDescription === \"Success\" ? payload = {\n                data: result.pageSize ? replaceNull(deleteKeysFromObject(result, [\"responseStatus\"])) : replaceNull(result.responseData[0]),\n                status: result.responseStatus,\n                loaded: true\n              } : payload = {\n                data: null,\n                status: result.responseStatus,\n                loaded: true\n              };\n              _context.next = 14;\n              break;\n\n            case 10:\n              _context.prev = 10;\n              _context.t0 = _context[\"catch\"](2);\n              console.error('error while fetchWithoutDispatch', _context.t0);\n              payload = {\n                data: null,\n                status: _context.t0.responseStatus ? _context.t0.responseStatus : {\n                  errorMessage: [{\n                    key: \"generic.error\",\n                    message: \"Server is down\"\n                  }],\n                  \"httpStatusCode\": 500,\n                  \"httpSubStatusCode\": 500,\n                  \"statusDesc\": \"ServerFailure\"\n                },\n                loaded: true\n              };\n\n            case 14:\n              return _context.abrupt(\"return\", Promise.resolve(payload));\n\n            case 15:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      }, _callee, null, [[2, 10]]);\n    }));\n\n    return function (_x) {\n      return _ref.apply(this, arguments);\n    };\n  }();\n}","map":{"version":3,"sources":["C:/Users/PIONEER/Documents/projects/endurance-sample/srabonti-sample-ui/src/utility/actionHelper.js"],"names":["isNullOrUndefined","replaceNull","deleteKeysFromObject","require","getDataApiOptions","requestOptions","requestBody","options","method","headers","authToken","body","JSON","stringify","fetchData","url","fetchRequest","Request","fetch","then","response","json","result","catch","error","fetchDataAndDispatch","dispatch","type","typeError","responseStatus","statusDescription","payload","data","responseData","loaded","console","log","errorMessage","key","message","getValueFromClientConfig","configObject","keyType","searchText","configValue","clientData","getObjectFromClientConfig","value","searchAndDispatch","searchFilters","pageSize","getDataApiOptionsNotAuthenticated","clientName","fetchWithoutDispatch","undefined","status","Promise","resolve"],"mappings":"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","sourcesContent":["import { isNullOrUndefined } from \"util\";\nimport { replaceNull, deleteKeysFromObject } from '../utility/generalFunctions';\nrequire('isomorphic-fetch');\n\n\nexport function getDataApiOptions(requestOptions, requestBody) {\n  let options = {\n    method: requestOptions.method,\n    headers: {\n      'Accept': 'application/json',\n      'Content-Type': 'application/json',\n      'Authorization': 'Bearer ' + requestOptions.authToken\n    }\n  }\n  if (!isNullOrUndefined(requestBody)) {\n    options.body = JSON.stringify(requestBody);\n  }\n  return options;\n}\n\n \n\nexport const fetchData = (url, options) => {\n  const fetchRequest = new Request(url, options);\n  return fetch(fetchRequest)\n    .then(response => response.json().then(result => ({ result })))\n    .catch(error => ({ error }));\n};\n\n\nexport function fetchDataAndDispatch(url, options, dispatch, type, typeError) {\n  const fetchRequest = new Request(url, options);\n  return fetch(fetchRequest)\n    .then(response => response.json().then(result => {\n      result.responseStatus.statusDescription === \"Success\" ? dispatch(\n        {\n          type,\n          payload: {\n            data: (result.responseData[0]),\n            error: null,\n            loaded: true\n          }\n        })\n        : dispatch({\n          type: type,\n          payload: {\n            data: null,\n            error: result.responseStatus,\n            loaded: true\n          }\n        });\n    }))\n    .catch(error => {\n      console.log(error)\n      dispatch({\n        type: type,\n        payload: {\n          data: null,\n          error: error.responseStatus ? error.responseStatus : {\n            errorMessage: [{\n              key: \"generic.error\",\n              message: \"Server is down\"\n            }],\n            \"httpStatusCode\": 500,\n            \"httpSubStatusCode\": 500,\n            \"statusDesc\": \"ServerFailure\"\n          },\n          loaded: true\n        }\n      })\n    });\n}\n\n\n// //TODO: account for multiple types in array\n// export function fetchDataAndDispatchWithPromise(url, options, dispatch, type, typeError) {\n//  try {\n//     const responseData = await this.fetchDataAndDispatch(url, options, dispatch, type);  \n//   }\n//   catch (err) { \n//   }\n//   return Promise.resolve();\n// };\n\n\n/**\n * returns object from clientconfig based on the key specified.\n * @param {object} configObject \n * @param {string} key \n */\n\n\n/**\n * returns a value from clientconfig based on the key specified.\n * @param {object} configObject \n * @param {string} key \n */\nexport const getValueFromClientConfig = (configObject, key, keyType, searchText) => {\n  let configValue = null;\n  let clientData = getObjectFromClientConfig(configObject, key, keyType, searchText);\n  if (clientData) {\n    const value = `${keyType}Value`;\n    configValue = clientData[value];\n  }\n  return configValue;\n}\n\nexport function searchAndDispatch(url, options, dispatch, type, searchFilters) {\n  const fetchRequest = new Request(url, options);\n  return fetch(fetchRequest)\n    .then(response => response.json().then(result => {\n      result.responseStatus.statusDescription === \"Success\" ? dispatch(\n        {\n          type,\n          payload: {\n            data: result.pageSize ? replaceNull(deleteKeysFromObject(result, [\"responseStatus\"])) : replaceNull(result.responseData[0]),\n            error: null,\n            loaded: true\n          },\n          searchFilters: searchFilters\n        })\n        : dispatch({\n          type: type,\n          payload: {\n            data: null,\n            error: result.responseStatus,\n            loaded: true\n          },\n          searchFilters: searchFilters\n        });\n    }))\n    .catch(error => {\n      console.log(error)\n      dispatch({\n        type: type,\n        payload: {\n          data: null,\n          error: error.responseStatus ? error.responseStatus : {\n            errorMessage: [{\n              key: \"generic.error\",\n              message: \"Server is down\"\n            }],\n            \"httpStatusCode\": 500,\n            \"httpSubStatusCode\": 500,\n            \"statusDesc\": \"ServerFailure\"\n          },\n          loaded: true\n        },\n        searchFilters: searchFilters\n      })\n    });\n}\n\nexport function getDataApiOptionsNotAuthenticated(requestOptions, requestBody) {\n  const options = {\n    method: requestOptions.method,\n    headers: {\n      'Accept': 'application/json',\n      'Content-Type': 'application/json',\n      'Client-Name': requestOptions.clientName\n    },\n    body: JSON.stringify(requestBody)\n  }\n  return options;\n}\n\nexport function fetchWithoutDispatch(url, options) {\n  return async (dispatch) => {\n    let response = undefined;\n    let payload = undefined;\n    try {\n      response = await fetchData(url, options);\n      let result = response.result;\n      result.responseStatus.statusDescription === \"Success\" ?\n        payload = {\n          data: result.pageSize ? replaceNull(deleteKeysFromObject(result, [\"responseStatus\"])) : replaceNull(result.responseData[0]),\n          status: result.responseStatus,\n          loaded: true\n        } :\n        payload = {\n          data: null,\n          status: result.responseStatus,\n          loaded: true\n        }\n    }\n    catch (err) {\n      console.error('error while fetchWithoutDispatch', err);\n      payload = {\n        data: null,\n        status: err.responseStatus ? err.responseStatus : {\n          errorMessage: [{\n            key: \"generic.error\",\n            message: \"Server is down\"\n          }],\n          \"httpStatusCode\": 500,\n          \"httpSubStatusCode\": 500,\n          \"statusDesc\": \"ServerFailure\"\n        },\n        loaded: true\n      }\n    }\n    return Promise.resolve(payload);\n  };\n}"]},"metadata":{},"sourceType":"module"}